//https://www.w3schools.com/js/js_json.asp
//This dictionary was generated programmatically with Python
var graphemes = {' ': ' ',
    '0': '‚Üò',
    '1': 'À©',
    '2': 'À®',
    '3': 'Àß',
    '4': 'À¶',
    '5': 'À•',
    '6': '‚Üì',
    '7': '‚Üë',
    '9': '‚Üó',
    'A': '…ë',
    'A)': '…í',
    'E': '…õ',
    'E"': '…ú',
    'E)': '≈ì',
    'I': '…™',
    'I"': '…ò',
    'O': '…î',
    'O"': '…û',
    'O(': ' å',
    'U': ' ä',
    'Y': ' è',
    '@': '√¶',
    '*': '*',
    '*+': '\\\\',
    '*-': 'Õç',
    '*%': 'Ãë',
    '*_': 'Õ¢',
    '*=': 'Ãª',
    '*H': '‚Åº',
    '*W': ' ¨',
    '*M': '\uf07d',
    '*G': '\uf005',
    '*K': '\uf004',
    '*P': '¬°',
    '*>': 'Õî',
    '*<': 'Õï',
    '*R': '‚ÜÄ',
    '*"': 'Õà',
    '*.': 'Õâ',
    '*)': '‚Çé',
    '*(': '‚Çç',
    '*B': ' ±',
    '*C': 'Ã∞',
    '*N': '\uf006',
    '*D': 'Õä',
    '*L': '\uf07c',
    '*V': '‚Üì',
    '*|': 'Õé',
    '*X': '\uf003',
    '*F': ' ©',
    '*~': 'Õå',
    '*T': ' ≠',
    '*S': 'Íûé',
    '*Z': '\uf035',
    '?': ' î',
    '?;': ' ¢',
    '?+': ' °',
    '?H': ' ï', "'": ' º', "'+": 'Àñ', "'-": '‚Åª', "'%": 'Ãë', "';": 'Àï', "',": 'Ãç', "'_": 'ÀΩ', "'H": ' ∞', "'W": ' ∑', "'M": 'Ãº', "'J": ' ≤', "'G": 'À†', "'P": 'À§', "'!": '·∑µ', "'>": 'Í≠™', "'<": 'Í≠´', "'R": 'Àû',
    '\'"': 'Ãà', "'`": 'Ãö', "')": 'Õó', "'(": 'Õë', "'B": ' ±', "'C": 'Ã∞', "'N": '‚Åø', "'D": 'ÕÜ', "'=": 'Ãª', "'L": 'À°', "'|": 'Ã¥', "'X": 'ÃΩ', "'F": 'Ãä', "'V": 'Ãå', "'~": 'ÃÉ',
    '^': '^',
    '^+': 'Àñ',
    '^-': 'Àó',
    '^%': '·µî',
    '^;': 'Àï',
    '^,': 'Àà',
    '^_': 'ÀΩ',
    '^H': ' ∞',
    '^W': ' ∑',
    '^M': 'Ãº',
    '^J': ' ≤',
    '^G': 'À†',
    '^P': 'À§',
    '^!': 'Àî',
    '^>': 'Í≠™',
    '^<': 'Í≠´',
    '^R': 'Àû',
    '^"': '¬®',
    '^`': 'À∫',
    '^)': 'Àí',
    '^(': 'Àì',
    '^B': ' ±',
    '^C': 'Ã∞',
    '^N': '‚Åø',
    '^D': 'Ã™',
    '^=': '‚ñ´',
    '^L': 'À°',
    '^|': 'Ã¥',
    '^X': 'À£',
    '^F': 'À≥',
    '^V': 'À¨',
    '^~': 'Àú',
    '/': '/',
    '/+': 'Ãü',
    '/-': 'Ã†',
    '/%': 'ÃØ',
    '/;': 'Ãû',
    '/,': 'Ã©',
    '/_': 'Ã∫',
    '/H': '‚Çï',
    '/W': ' ∑',
    '/M': 'Ãº',
    '/J': '‚±º',
    '/G': '·µß',
    '/P': '‚Çö',
    '/!': 'Ãù',
    '/>': 'Ãò',
    '/<': 'Ãô',
    '/R': 'Àû',
    '/"': 'Ã§',
    '/`': 'Õâ',
    '/)': 'Ãπ',
    '/(': 'Ãú',
    '/B': 'Ã§',
    '/C': 'Ã∞',
    '/N': '‚Çô',
    '/D': 'Ã™',
    '/=': 'Ãª',
    '/L': '‚Çó',
    '/|': 'Ã¥',
    '/X': '‚Çì',
    '/F': 'Ã•',
    '/V': 'Ã¨',
    '/~': 'Ã∞',
    '.': '.',
    '.+': 'Àê',
    '.-': 'Àë',
    '.%': 'ÃÜ', ".'": 'Àà',
    '.,': 'Àå',
    '.:': '‚Äñ',
    '.|': '|',
    '._': 'Õú',
    '.=': 'Õ°',
    '.(': '‚ÅÄ',
    '.)': '‚Äø',
    '\\ ': ' ',
    '\\!': '!',
    '\\"': '"',
    '\\#': '#',
    '\\$': '$',
    '\\%': '%',
    '\\&': '&', "\\'": "\\'", '\\(': '(',
    '\\)': ')',
    '\\*': '*',
    '\\+': '+',
    '\\,': ',',
    '\\-': '-',
    '\\.': '.',
    '\\/': '/',
    '\\0': '0',
    '\\1': '1',
    '\\2': '2',
    '\\3': '3',
    '\\4': '4',
    '\\5': '5',
    '\\6': '6',
    '\\7': '7',
    '\\8': '8',
    '\\9': '9',
    '\\:': ':',
    '\\;': ';',
    '\\<': '<',
    '\\=': '=',
    '\\>': '>',
    '\\?': '?',
    '\\@': '@',
    '\\A': 'A',
    '\\B': 'B',
    '\\C': 'C',
    '\\D': 'D',
    '\\E': 'E',
    '\\F': 'F',
    '\\G': 'G',
    '\\H': 'H',
    '\\I': 'I',
    '\\J': 'J',
    '\\K': 'K',
    '\\L': 'L',
    '\\M': 'M',
    '\\N': 'N',
    '\\O': 'O',
    '\\P': 'P',
    '\\Q': 'Q',
    '\\R': 'R',
    '\\S': 'S',
    '\\T': 'T',
    '\\U': 'U',
    '\\V': 'V',
    '\\W': 'W',
    '\\X': 'X',
    '\\Y': 'Y',
    '\\Z': 'Z',
    '\\[': '[',
    '\\\\': '\\',
    '\\]': ']',
    '\\^': '^',
    '\\_': '_',
    '\\`': '`',
    '\\a': 'a',
    '\\b': 'b',
    '\\c': 'c',
    '\\d': 'd',
    '\\e': 'e',
    '\\f': 'f',
    '\\g': 'g',
    '\\h': 'h',
    '\\i': 'i',
    '\\j': 'j',
    '\\k': 'k',
    '\\l': 'l',
    '\\m': 'm',
    '\\n': 'n',
    '\\o': 'o',
    '\\p': 'p',
    '\\q': 'q',
    '\\r': 'r',
    '\\s': 's',
    '\\t': 't',
    '\\u': 'u',
    '\\v': 'v',
    '\\w': 'w',
    '\\x': 'x',
    '\\y': 'y',
    '\\z': 'z',
    '\\{': '{',
    '\\|': '|',
    '\\}': '}',
    '\\~': '~',
    'a': 'a',
    'a"': '…ê',
    'a)': '…∂',
    'b': 'b',
    'b<': '…ì',
    'b!': ' ò',
    'bB': ' ô',
    'bH': 'Œ≤',
    'c': 'c',
    'c<': ' Ñ',
    'c!': '«Ç',
    'cH': '√ß',
    'cL': 'ùºÜ',
    'd': 'd',
    'd<': '…ó',
    'd!': '«Ä',
    'd-': '…ñ',
    'dH': '√∞',
    'e': 'e',
    'e"': '…ô',
    'e)': '√∏',
    'f': 'f',
    'g': 'g',
    'g<': '…†',
    'g-': '…¢',
    'gH': '…£',
    'gQ': '\uf001',
    'gJ': '…ü',
    'gL': ' ü',
    'h': 'h',
    'h"': '…¶',
    'hH': ' ú',
    'h+': 'ƒß',
    'i': 'i',
    'i"': '…®',
    'j': 'j',
    'jW': '…•',
    'jL': ' é',
    'jH': ' ù',
    'k': 'k',
    'l': 'l',
    'l-': '…≠',
    'l`': '…∫',
    'l!': '«Å',
    'lS': ' ™',
    'lZ': ' ´',
    'm': 'm',
    'm-': '…±',
    'n': 'n',
    'n-': '…≥',
    'nJ': '…≤',
    'nG': '≈ã',
    'nQ': '…¥',
    'o': 'o',
    'o"': '…µ',
    'o(': '…§',
    'p': 'p',
    'pH': '…∏',
    'q': 'q',
    'q<': ' õ',
    'qR': ' Ä',
    'qQ': '\uf000',
    'r': 'r',
    'r-': '…ª',
    'rT': '…Ω',
    'r"': '…π',
    'r|': 'ùºä',
    'rH': ' Å',
    'r`': '…æ',
    'r!': '‚Äº',
    's': 's',
    's-': ' Ç',
    'sJ': '…ï',
    'sL': '…¨',
    'sH': ' É',
    't': 't',
    't!': '«É',
    't-': ' à',
    'tH': 'Œ∏',
    'u': 'u',
    'u"': ' â',
    'u(': '…Ø',
    'v': 'v',
    'vW': ' ã',
    'v`': '‚±±',
    'w': 'w',
    'w(': '…∞',
    'x': 'x',
    'x-': 'œá',
    'xW': ' ç',
    'xH': '…ß',
    'xL': '\uf268',
    'y': 'y',
    'z': 'z',
    'zJ': ' ë',
    'zL': '…Æ',
    'z-': ' ê',
    'zH': ' í',
    '{': '‚ü®',
    '}': '‚ü©',
    '[': '[',
    ']': ']'};

//When the page first loads, all the text boxes with IPA text start as
//having the "arial" class.
var current_font_class = 'arial';
//I didn't feel like having parse return a tuple, so I store whether or not
//there was an error here
var parsing_error = false;

function error_message(input, i) {
    //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals
    let error_msg = `There was an error at character ${i}:<br><br>`;

    //On top of giving the index, we show the input with the
    //erroneous character emphasized.
        
    //We must avoid users putting in html code that works.
    let left = input.substring(0, i);
    //https://en.wikipedia.org/wiki/Private_Use_Areas
    //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll
    left = left.replaceAll("<", "\uF8FF");
    //https://developer.mozilla.org/en-US/docs/Web/HTML/Element/pre
    left = left.replaceAll(">", "<pre style=\"display: inline\">&gt;</pre>");
    left = left.replaceAll("\uF8FF",
        "<pre style=\"display: inline\">&lt;</pre>");
    error_msg += left
    error_msg += "<strong><em><u>" + input.substring(i, i+1);
    error_msg += "</strong></em></u>";
    if (i != input.length - 1) {
        let right = input.substr(i + 1, input.length);
        right = right.replaceAll("<", "\uF8FF");
        right = right.replaceAll(">",
            "<pre style=\"display: inline\">&gt;</pre>");
        right = right.replaceAll("\uF8FF",
            "<pre style=\"display: inline\">&lt;</pre>");
        error_msg += right;
    }
    return error_msg;
}

//https://www.w3schools.com/js/js_functions.asp
//Convert the input TIPO string to IPA and return it.
function parse(input){
    //Some context for non-phoneticians:
    //Grapheme = unit of writing representing a single sound
    //e.g. In English, "s", "sh", and "h" are single graphemes.
    //Digraph = A grapheme consisting of two symbols.
    //Monograph = A grapheme consisting of one symbol.

    //Start by assuming there was no error
    parsing_error = false;

    //https://www.w3schools.com/js/js_if_else.asp
    //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length
    //"" in TIPO is "" in IPA
    if (input.length == 0){
        return input;
    }
        
    let output = "";
    //We cache whether or not the last scanned grapheme was a digraph so
    //we can make some checks after the while loop.
    let last_digraph = false;
    let i = 0;
    //https://www.w3schools.com/js/js_loop_while.asp
    //We shouldn't use a for loop, since we don't always increment by a fixed
    //amount every iteration
    while (i < input.length - 1) {
        //https://www.w3schools.com/jsref/jsref_substring.asp
        //https://sentry.io/answers/difference-between-let-and-var-in-javascript/
        let substr = input.substring(i,i+2);
        let digraph_result = graphemes[substr];
        
        //https://stackoverflow.com/questions/19317943/why-referencing-non-existent-property-of-an-object-in-javascript-doesnt-return
        //We check for graphemes of length 2 first, since digraphs can
        //and almost always do contain a valid monograph.
        //Also, if a object does not have what we query it for, the result is
        //false-y/null-y. If it's not null, our digraph exists.
        if (digraph_result != null) {
            last_digraph = true;
            output += digraph_result;
            i += 2;
        } else {
            last_digraph = false;
            let substr = input.substring(i, i+1);
            let monograph_result = graphemes[substr];
            if (monograph_result != null) {
                output += monograph_result;
                i += 1;
            //If neither the digraph or monograph exist, that means the input
            //is not valid TIPO. We let the user know where the error was
            //so they can fix it.
            }else {
                parsing_error = true;
                return error_message(input, i);
            }
        }
    }

    let substr = input.substring(input.length - 1, input.length);
    let monograph_result = graphemes[substr];
    let semifinal_backslash = (input.length > 1 &&
        input.substring(input.length - 2, input.length - 1) == '\\');
    let semifinal_double_backslash = (input.length > 2 &&
        input.substring(input.length - 3, input.length - 1) === '\\\\');
    //We ignore the last character if it was preceded by a backslash,
    //since that's used as an escape character, possibly used with
    //"primary" characters (characters that are first in digraphs).
    //However, there's an edge case where the last 2 characters are backslashes
    //which should result in the last character being its own grapheme.
    if (monograph_result != null &&
        !(semifinal_backslash && !semifinal_double_backslash)){
        output += monograph_result;
    } else{
        //Technically, if the last grapheme was a digraph, our last character
        //won't be a valid monograph unless it was \ + an ascii character.
        //Regardless, we want to ignore the second character, since it was
        //already used.
        //However, if the second to last character was a monograph, and we
        //still have a non-monographic character at the end, that means
        //that the input was invalid.
        if (!last_digraph) {
            parsing_error = true;
            return error_message(input, i);
        } 
    }

    return output;
}

//Switch the font of all text whose purpose is to display IPA text.
function switch_fonts() {
    //We need to get the new font from the form.
    let converter_form = document.getElementById("ascii_converter");
    //https://developer.mozilla.org/en-US/docs/Web/API/FormData/get
    let form_data = new FormData(converter_form);
    //Cache the old font class for comparison.
    let old_font_class = current_font_class
    let ipa_texts = document.getElementsByClassName(old_font_class);
    current_font_class = form_data.get("font");

    //If we don't make this check, the while loop inside could go infinitely
    if (old_font_class != current_font_class) {
        //https://stackoverflow.com/questions/54404940/set-attributes-of-html-tag-using-pure-javascript
        //Apparently, the result of `getElementsByClassName`changes based on
        //the current state of the page and not the state when it was called.
        //Therefore, we need a while loop and not a for loop. I found this out
        //by debugging.
        do {
            ipa_texts[0].className = current_font_class;
        } while (ipa_texts.length > 0)
    }
}


//Clear the current text of ALL textarea elements on the page.
function clear_textareas() {
    let textareas = document.getElementsByTagName('textarea');

    //https://www.w3schools.com/js/js_loop_for.asp
    for (let i = 0; i < textareas.length; i++) {
        //https://stackoverflow.com/questions/14939010/get-value-from-text-area
        textareas[i].value = "";
    }
}

//Take input from the text area, parse it, and display the corresponding IPA.
//Additionally, display the difference in size between the input and output.
function input_to_output() {
    let converter_form = document.getElementById("ascii_converter");
    //https://developer.mozilla.org/en-US/docs/Web/API/FormData/get
    let form_data = new FormData(converter_form);
    let input = form_data.get("tipo_input");
    //https://labex.io/tutorials/javascript-calculating-string-byte-size-28182
    let input_bytes = new Blob([input]).size;

    var output = parse(form_data.get("tipo_input"));

    let output_bytes = new Blob([output]).size;
    let size_diff = output_bytes - input_bytes;

    //Generate the string for the size difference, wrapping the difference in
    //a <strong> tag.
    let size_str = "";
    //There's no point in making a comparison with an error message.
    if (!parsing_error) {
        size_str = "The output has <strong>";
        if (size_diff > 0) {
            size_str += size_diff + "</strong> more bytes than the input";
            //https://stackoverflow.com/questions/11832914/how-to-round-to-at-most-2-decimal-places-if-necessary
            size_str += "<em> (" + (output_bytes*100/input_bytes ).toFixed(1);
            size_str += "% bigger)</em>.";
        } else if (size_diff < 0) {
            size_str += -1*size_diff;
            size_str +=  "</strong> less bytes than the input";
            size_str += "<em> (" + (input_bytes*100/output_bytes ).toFixed(1);
            size_str += "% smaller)</em>.";
        } else {
            size_str += " the same</strong> number of bytes as the input.";
        }
    }
    
    
    //We use innerHTML instead of textContent so that the strong tags work.
    document.querySelector("#size_difference").innerHTML = size_str;

    //There's also no point in wrapping the error message with anything.
    if (!parsing_error) {
        let wrapper = form_data.get("wrapper");

        switch (wrapper){
            case "apostrophes":
                output = "'" + output + "'";
                break;
            case "quotes":
                output = '"' + output + '"';
                break;
            case "slashes":
                output = '/' + output + '/';
                break;
            case "brackets":
                output = '[' + output + ']';
                break;
            default:
                break;
        }
    }

    if (!parsing_error) {
        //We change the textContent out the output paragraph because we are not
        //formatting it with tags at all.
        document.getElementById("converter_output").textContent = output;
    } else {
        //However, there is formatting in the error message.
        document.getElementById("converter_output").innerHTML = output;
    }


    //https://www.w3schools.com/howto/howto_js_copy_clipboard.asp
    //We don't want to have the user copy something unexpectedly.
    if (form_data.get("copy") == "yes" && !parsing_error) {
        navigator.clipboard.writeText(output);
    }

    //https://stackoverflow.com/questions/64619241/how-do-you-change-a-html-text-after-form-submission
    return false;
}